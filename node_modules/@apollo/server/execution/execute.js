"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFieldDef = exports.defaultFieldResolver = exports.defaultTypeResolver = exports.resolveFieldValueOrError = exports.buildResolveInfo = exports.collectFields = exports.buildExecutionContext = exports.assertValidExecutionArguments = exports.execute = void 0;
const iterall_1 = require("iterall");
const jsutils_1 = require("./jsutils");
const Path_1 = require("graphql/jsutils/Path");
const error_1 = require("graphql/error");
const kinds_1 = require("graphql/language/kinds");
const validate_1 = require("graphql/type/validate");
const introspection_1 = require("graphql/type/introspection");
const directives_1 = require("graphql/type/directives");
const definition_1 = require("graphql/type/definition");
const typeFromAST_1 = require("graphql/utilities/typeFromAST");
const getOperationRootType_1 = require("graphql/utilities/getOperationRootType");
const values_1 = require("graphql/execution/values");
function execute(args) {
    const { schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver, } = args;
    assertValidExecutionArguments(schema, document, variableValues);
    const exeContext = buildExecutionContext(schema, document, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver);
    function isExecutionContext(maybeContext) {
        return !Array.isArray(maybeContext);
    }
    if (!isExecutionContext(exeContext)) {
        return { errors: exeContext };
    }
    const data = executeOperation(exeContext, exeContext.operation, rootValue);
    return buildResponse(exeContext, data);
}
exports.execute = execute;
function buildResponse(exeContext, data) {
    if (jsutils_1.isPromise(data)) {
        return data.then(resolved => buildResponse(exeContext, resolved));
    }
    return exeContext.errors.length === 0
        ? { data }
        : { errors: exeContext.errors, data };
}
function assertValidExecutionArguments(schema, document, rawVariableValues) {
    jsutils_1.devAssert(document, 'Must provide document');
    validate_1.assertValidSchema(schema);
    jsutils_1.devAssert(rawVariableValues == null || jsutils_1.isObjectLike(rawVariableValues), 'Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.');
}
exports.assertValidExecutionArguments = assertValidExecutionArguments;
function buildExecutionContext(schema, document, rootValue, contextValue, rawVariableValues, operationName, fieldResolver, typeResolver) {
    let operation;
    const fragments = Object.create(null);
    for (const definition of document.definitions) {
        switch (definition.kind) {
            case kinds_1.Kind.OPERATION_DEFINITION:
                if (operationName == null) {
                    if (operation !== undefined) {
                        return [
                            new error_1.GraphQLError('Must provide operation name if query contains multiple operations.'),
                        ];
                    }
                    operation = definition;
                }
                else if (definition.name && definition.name.value === operationName) {
                    operation = definition;
                }
                break;
            case kinds_1.Kind.FRAGMENT_DEFINITION:
                fragments[definition.name.value] = definition;
                break;
        }
    }
    if (!operation) {
        if (operationName != null) {
            return [new error_1.GraphQLError(`Unknown operation named "${operationName}".`)];
        }
        return [new error_1.GraphQLError('Must provide an operation.')];
    }
    const coercedVariableValues = values_1.getVariableValues(schema, operation.variableDefinitions || [], rawVariableValues || {}, { maxErrors: 50 });
    if (coercedVariableValues.errors) {
        return coercedVariableValues.errors;
    }
    return {
        schema,
        fragments,
        rootValue,
        contextValue,
        operation,
        variableValues: coercedVariableValues.coerced,
        fieldResolver: fieldResolver || exports.defaultFieldResolver,
        typeResolver: typeResolver || exports.defaultTypeResolver,
        errors: [],
    };
}
exports.buildExecutionContext = buildExecutionContext;
function executeOperation(exeContext, operation, rootValue) {
    const type = getOperationRootType_1.getOperationRootType(exeContext.schema, operation);
    const fields = collectFields(exeContext, type, operation.selectionSet, Object.create(null), Object.create(null));
    const path = undefined;
    try {
        const result = operation.operation === 'mutation'
            ? executeFieldsSerially(exeContext, type, rootValue, path, fields)
            : executeFields(exeContext, type, rootValue, path, fields);
        if (jsutils_1.isPromise(result)) {
            return result.then(undefined, error => {
                exeContext.errors.push(error);
                return Promise.resolve(null);
            });
        }
        return result;
    }
    catch (error) {
        exeContext.errors.push(error);
        return null;
    }
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
    return jsutils_1.promiseReduce(Object.keys(fields), (results, responseName) => {
        const fieldNodes = fields[responseName];
        const fieldPath = Path_1.addPath(path, responseName, parentType.name);
        const result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result === undefined) {
            return results;
        }
        if (jsutils_1.isPromise(result)) {
            return result.then(resolvedResult => {
                results[responseName] = resolvedResult;
                return results;
            });
        }
        results[responseName] = result;
        return results;
    }, Object.create(null));
}
function executeFields(exeContext, parentType, sourceValue, path, fields) {
    const results = Object.create(null);
    let containsPromise = false;
    for (const responseName of Object.keys(fields)) {
        const fieldNodes = fields[responseName];
        const fieldPath = Path_1.addPath(path, responseName, parentType.name);
        const result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
        if (result !== undefined) {
            results[responseName] = result;
            if (!containsPromise && jsutils_1.isPromise(result)) {
                containsPromise = true;
            }
        }
    }
    if (!containsPromise) {
        return results;
    }
    return jsutils_1.promiseForObject(results);
}
function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {
    for (const selection of selectionSet.selections) {
        switch (selection.kind) {
            case kinds_1.Kind.FIELD: {
                if (!shouldIncludeNode(exeContext, selection)) {
                    continue;
                }
                const name = getFieldEntryKey(selection);
                if (!fields[name]) {
                    fields[name] = [];
                }
                fields[name].push(selection);
                break;
            }
            case kinds_1.Kind.INLINE_FRAGMENT: {
                if (!shouldIncludeNode(exeContext, selection) ||
                    !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
                    continue;
                }
                collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
                break;
            }
            case kinds_1.Kind.FRAGMENT_SPREAD: {
                const fragName = selection.name.value;
                if (visitedFragmentNames[fragName] ||
                    !shouldIncludeNode(exeContext, selection)) {
                    continue;
                }
                visitedFragmentNames[fragName] = true;
                const fragment = exeContext.fragments[fragName];
                if (!fragment ||
                    !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
                    continue;
                }
                collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
                break;
            }
        }
    }
    return fields;
}
exports.collectFields = collectFields;
function shouldIncludeNode(exeContext, node) {
    const skip = values_1.getDirectiveValues(directives_1.GraphQLSkipDirective, node, exeContext.variableValues);
    if (skip && skip.if === true) {
        return false;
    }
    const include = values_1.getDirectiveValues(directives_1.GraphQLIncludeDirective, node, exeContext.variableValues);
    if (include && include.if === false) {
        return false;
    }
    return true;
}
function doesFragmentConditionMatch(exeContext, fragment, type) {
    const typeConditionNode = fragment.typeCondition;
    if (!typeConditionNode) {
        return true;
    }
    const conditionalType = typeFromAST_1.typeFromAST(exeContext.schema, typeConditionNode);
    if (conditionalType === type) {
        return true;
    }
    if (definition_1.isAbstractType(conditionalType)) {
        return exeContext.schema.isSubType(conditionalType, type);
    }
    return false;
}
function getFieldEntryKey(node) {
    return node.alias ? node.alias.value : node.name.value;
}
function resolveField(exeContext, parentType, source, fieldNodes, path) {
    const fieldNode = fieldNodes[0];
    const fieldName = fieldNode.name.value;
    const fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
    if (!fieldDef) {
        return;
    }
    const resolveFn = fieldDef.resolve || exeContext.fieldResolver;
    const info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
    const result = resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info);
    return completeValueCatchingError(exeContext, fieldDef.type, fieldNodes, info, path, result);
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
    return {
        fieldName: fieldDef.name,
        fieldNodes,
        returnType: fieldDef.type,
        parentType,
        path,
        schema: exeContext.schema,
        fragments: exeContext.fragments,
        rootValue: exeContext.rootValue,
        operation: exeContext.operation,
        variableValues: exeContext.variableValues,
        cacheControl: {
            setCacheHint() { },
            cacheHint: {
                maxAge: 0,
                scope: require('apollo-cache-control').CacheScope.public
            }
        }
    };
}
exports.buildResolveInfo = buildResolveInfo;
function resolveFieldValueOrError(exeContext, fieldDef, fieldNodes, resolveFn, source, info) {
    try {
        const args = values_1.getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues);
        const contextValue = exeContext.contextValue;
        const result = resolveFn(source, args, contextValue, info);
        return jsutils_1.isPromise(result) ? result.then(undefined, asErrorInstance) : result;
    }
    catch (error) {
        return asErrorInstance(error);
    }
}
exports.resolveFieldValueOrError = resolveFieldValueOrError;
function asErrorInstance(error) {
    if (error instanceof Error) {
        return error;
    }
    return new Error('Unexpected error value: ' + jsutils_1.inspect(error));
}
function completeValueCatchingError(exeContext, returnType, fieldNodes, info, path, result) {
    try {
        let completed;
        if (jsutils_1.isPromise(result)) {
            completed = result.then(resolved => completeValue(exeContext, returnType, fieldNodes, info, path, resolved));
        }
        else {
            completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
        }
        if (jsutils_1.isPromise(completed)) {
            return completed.then(undefined, error => handleFieldError(error, fieldNodes, path, returnType, exeContext));
        }
        return completed;
    }
    catch (error) {
        return handleFieldError(error, fieldNodes, path, returnType, exeContext);
    }
}
function handleFieldError(rawError, fieldNodes, path, returnType, exeContext) {
    const error = error_1.locatedError(asErrorInstance(rawError), fieldNodes, Path_1.pathToArray(path));
    if (definition_1.isNonNullType(returnType)) {
        throw error;
    }
    exeContext.errors.push(error);
    return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (result instanceof Error) {
        throw result;
    }
    if (definition_1.isNonNullType(returnType)) {
        const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
        if (completed === null) {
            throw new Error(`Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`);
        }
        return completed;
    }
    if (jsutils_1.isNullish(result)) {
        return null;
    }
    if (definition_1.isListType(returnType)) {
        return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if (definition_1.isLeafType(returnType)) {
        return completeLeafValue(returnType, result);
    }
    if (definition_1.isAbstractType(returnType)) {
        return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if (definition_1.isObjectType(returnType)) {
        return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    jsutils_1.invariant(false, 'Cannot complete value of unexpected output type: ' +
        jsutils_1.inspect(returnType));
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (!iterall_1.isCollection(result)) {
        throw new error_1.GraphQLError(`Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`);
    }
    const itemType = returnType.ofType;
    let containsPromise = false;
    const completedResults = [];
    iterall_1.forEach(result, (item, index) => {
        const fieldPath = Path_1.addPath(path, index, undefined);
        const completedItem = completeValueCatchingError(exeContext, itemType, fieldNodes, info, fieldPath, item);
        if (!containsPromise && jsutils_1.isPromise(completedItem)) {
            containsPromise = true;
        }
        completedResults.push(completedItem);
    });
    return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeLeafValue(returnType, result) {
    const serializedResult = returnType.serialize(result);
    if (jsutils_1.isInvalid(serializedResult)) {
        throw new Error(`Expected a value of type "${jsutils_1.inspect(returnType)}" but ` +
            `received: ${jsutils_1.inspect(result)}`);
    }
    return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
    const resolveTypeFn = returnType.resolveType || exeContext.typeResolver;
    const contextValue = exeContext.contextValue;
    const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
    if (jsutils_1.isPromise(runtimeType)) {
        return runtimeType.then(resolvedRuntimeType => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result));
    }
    return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
}
function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {
    const runtimeType = typeof runtimeTypeOrName === 'string'
        ? exeContext.schema.getType(runtimeTypeOrName)
        : runtimeTypeOrName;
    if (!definition_1.isObjectType(runtimeType)) {
        throw new error_1.GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with ` +
            `value ${jsutils_1.inspect(result)}, received "${jsutils_1.inspect(runtimeType)}". ` +
            `Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
    }
    if (!exeContext.schema.isSubType(returnType, runtimeType)) {
        throw new error_1.GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, fieldNodes);
    }
    return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
    if (returnType.isTypeOf) {
        const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
        if (jsutils_1.isPromise(isTypeOf)) {
            return isTypeOf.then(resolvedIsTypeOf => {
                if (!resolvedIsTypeOf) {
                    throw invalidReturnTypeError(returnType, result, fieldNodes);
                }
                return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
            });
        }
        if (!isTypeOf) {
            throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
    }
    return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
    return new error_1.GraphQLError(`Expected value of type "${returnType.name}" but got: ${jsutils_1.inspect(result)}.`, fieldNodes);
}
function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {
    const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
    return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
const collectSubfields = jsutils_1.memoize3(_collectSubfields);
function _collectSubfields(exeContext, returnType, fieldNodes) {
    let subFieldNodes = Object.create(null);
    const visitedFragmentNames = Object.create(null);
    for (const node of fieldNodes) {
        if (node.selectionSet) {
            subFieldNodes = collectFields(exeContext, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
        }
    }
    return subFieldNodes;
}
exports.defaultTypeResolver = function (value, contextValue, info, abstractType) {
    if (jsutils_1.isObjectLike(value) && typeof value.__typename === 'string') {
        return value.__typename;
    }
    const possibleTypes = info.schema.getPossibleTypes(abstractType);
    const promisedIsTypeOfResults = [];
    for (let i = 0; i < possibleTypes.length; i++) {
        const type = possibleTypes[i];
        if (type.isTypeOf) {
            const isTypeOfResult = type.isTypeOf(value, contextValue, info);
            if (jsutils_1.isPromise(isTypeOfResult)) {
                promisedIsTypeOfResults[i] = isTypeOfResult;
            }
            else if (isTypeOfResult) {
                return type;
            }
        }
    }
    if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then(isTypeOfResults => {
            for (let i = 0; i < isTypeOfResults.length; i++) {
                if (isTypeOfResults[i]) {
                    return possibleTypes[i];
                }
            }
            return;
        });
    }
    return;
};
exports.defaultFieldResolver = function (source, args, contextValue, info) {
    if (jsutils_1.isObjectLike(source) || typeof source === 'function') {
        const property = source[info.fieldName];
        if (typeof property === 'function') {
            return source[info.fieldName](args, contextValue, info);
        }
        return property;
    }
};
function getFieldDef(schema, parentType, fieldName) {
    if (fieldName === introspection_1.SchemaMetaFieldDef.name &&
        schema.getQueryType() === parentType) {
        return introspection_1.SchemaMetaFieldDef;
    }
    else if (fieldName === introspection_1.TypeMetaFieldDef.name &&
        schema.getQueryType() === parentType) {
        return introspection_1.TypeMetaFieldDef;
    }
    else if (fieldName === introspection_1.TypeNameMetaFieldDef.name) {
        return introspection_1.TypeNameMetaFieldDef;
    }
    return parentType.getFields()[fieldName];
}
exports.getFieldDef = getFieldDef;
//# sourceMappingURL=execute.js.map