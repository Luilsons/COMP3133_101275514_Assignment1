"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const snapshotSerializers_1 = require("../../snapshotSerializers");
const apollo_server_core_1 = require("apollo-server-core");
const apollo_tools_1 = require("@apollographql/apollo-tools");
const graphql_1 = require("graphql");
expect.addSnapshotSerializer(snapshotSerializers_1.astSerializer);
const graphql = String.raw;
const validQueries = {
    "basic - { people { name } }": {
        query: graphql `
      query Basic {
        people {
          name
        }
      }
    `
    },
    "with nested selection sets - { people { name friends { name friends { name } } } }": {
        query: graphql `
      query Nested {
        people {
          name
          friends {
            name
            friends {
              name
            }
          }
        }
      }
    `
    },
    "with directives - { people { name { friends { name } } }": {
        query: graphql `
      query Directives($includeFriends: Boolean!) {
        people {
          name
          friends @include(if: $includeFriends) {
            name
          }
        }
      }
    `,
        variables: { includeFriends: true }
    },
    "with multiple documents - { people { name } }": {
        query: graphql `
      query FirstDocument {
        people {
          name
        }
      }

      query SecondDocument {
        people {
          id
        }
      }
    `,
        operationName: "FirstDocument"
    }
};
const unparseableQueries = {
    "missing closing }": `
      query Basic {
        people {
          name
        }
    `,
    "empty selection set": `
      query Nested {
        people { }
      }
    `,
    "empty query": `
      query Empty {}
    `
};
const invalidQueries = {
    basic: {
        query: graphql `
      query Basic {
        invalidField
      }
    `
    },
    "with invalid selection sets": {
        query: graphql `
      query Nested {
        people {
          name
          invalidField
        }
      }
    `
    },
    "missing directive": {
        query: graphql `
      query MissingDirective {
        people @invalid {
          name
        }
      }
    `
    },
    "with multiple errors": {
        query: graphql `
      query FirstDocument {
        people {
          invalidOne
        }
        invalidTwo
      }
    `
    }
};
const nonExecutableQueries = {
    "error field throws": {
        query: graphql `
      query {
        error
      }
    `
    },
    "throws multiple errors": {
        query: graphql `
      query {
        error
        people {
          nestedError
        }
      }
    `
    }
};
const serverTeam = [
    { id: 1, name: "James Baxley" },
    { id: 2, name: "Ashi Krishnan" },
    { id: 3, name: "Jesse Rosenberger" },
    { id: 4, name: "Trevor Scheer" }
];
const serviceDefinition = apollo_tools_1.buildServiceDefinition([
    {
        typeDefs: apollo_server_core_1.gql `
      type Query {
        people: [Person]
        error: String
        modifiesContext: String
      }

      type Person {
        id: ID
        name: String
        friends: [Person]
        nestedError: String
      }
    `,
        resolvers: {
            Query: {
                people() {
                    return serverTeam;
                },
                error() {
                    throw new graphql_1.GraphQLError("Error while resolving `error` field");
                },
                modifiesContext(_, __, context) {
                    context.modified = true;
                    return "Context modified!";
                }
            },
            Person: {
                async friends(parentValue) {
                    return serverTeam.filter(({ id }) => id !== parentValue.id);
                },
                nestedError() {
                    throw new graphql_1.GraphQLError("Error while resolving `nestedError` field");
                }
            }
        }
    }
]);
const schema = serviceDefinition.schema;
const validQueryTests = Object.entries(validQueries);
const unparseableQueryTests = Object.entries(unparseableQueries);
const invalidQueryTests = Object.entries(invalidQueries);
const nonExecutableQueryTests = Object.entries(nonExecutableQueries);
describe("parseGraphqlRequest", () => {
    it.each(validQueryTests)("Parses valid queries - %s", (_, { query }) => {
        const parseResult = __1.parseGraphqlRequest({ query });
        if ("error" in parseResult) {
            throw new Error("Unexpected parse failure in parseable query. Are you sure you added a valid query to the validQueries test cases?");
        }
        expect(parseResult.document).toMatchSnapshot();
    });
    it.each(unparseableQueryTests)("Returns an error for invalid queries - %s", (_, query) => {
        const parseResult = __1.parseGraphqlRequest({ query });
        if ("document" in parseResult) {
            throw new Error("Unexpected successful parse in unparseable query. Are you sure you added an unparseable query to the unparseableQueries test cases?");
        }
        expect(parseResult.error).toMatchSnapshot();
    });
});
describe("validateGraphqlRequest", () => {
    it.each(validQueryTests)("valid queries against schema: %s", (_, { query, operationName }) => {
        const parseResult = __1.parseGraphqlRequest({ query });
        if ("error" in parseResult) {
            throw new Error("Unexpected parse failure in parseable query. Are you sure you added a valid query to the validQueries test cases?");
        }
        const validationErrors = __1.validateGraphqlRequest({
            schema,
            document: parseResult.document,
            operationName
        });
        expect(validationErrors).toHaveLength(0);
    });
    it.each(invalidQueryTests)("invalid queries against schema: %s", (_, { query, operationName }) => {
        const parseResult = __1.parseGraphqlRequest({ query });
        if ("error" in parseResult) {
            throw new Error("Unexpected parse failure in parseable query. Are you sure you added a parseable query to the invalidQueries test cases?");
        }
        const validationErrors = __1.validateGraphqlRequest({
            schema,
            document: parseResult.document,
            operationName
        });
        expect(validationErrors).toMatchSnapshot();
    });
});
describe("executeGraphqlRequest", () => {
    it.each(validQueryTests)("Executable queries - %s", async (_, { query, operationName, variables }) => {
        const parseResult = __1.parseGraphqlRequest({ query });
        if ("error" in parseResult) {
            throw new Error("Unexpected parse failure in parseable query. Are you sure you added a parseable query to the validQueries test cases?");
        }
        const result = await __1.executeGraphqlRequest({
            schema,
            document: parseResult.document,
            operationName,
            variables
        });
        expect(result).toMatchSnapshot();
    });
    it.each(nonExecutableQueryTests)("Errors during execution - %s", async (_, { query }) => {
        const parseResult = __1.parseGraphqlRequest({ query });
        if ("error" in parseResult) {
            throw new Error("Unexpected parse failure in parseable query. Are you sure you added a parseable query to the nonExecutableQueries test cases?");
        }
        const { errors } = await __1.executeGraphqlRequest({
            schema,
            document: parseResult.document
        });
        expect(errors.length).toBeGreaterThan(0);
        expect(errors).toMatchSnapshot();
    });
});
describe("processGraphqlRequest", () => {
    it.each(validQueryTests)("Executable queries - %s", async (_, { query, operationName, variables }) => {
        const { data, errors } = await __1.processGraphqlRequest({
            schema,
            request: {
                query,
                operationName,
                variables
            }
        });
        expect(errors).toBeUndefined();
        expect(data).toMatchSnapshot();
    });
    it.each(unparseableQueryTests)("Unparseable queries - %s", async (_, query) => {
        const { errors } = await __1.processGraphqlRequest({
            schema,
            request: {
                query
            }
        });
        expect(errors).toMatchSnapshot();
    });
    it.each(invalidQueryTests)("Invalid queries - %s", async (_, { query, operationName }) => {
        const { errors } = await __1.processGraphqlRequest({
            schema,
            request: {
                query,
                operationName
            }
        });
        expect(errors).toMatchSnapshot();
    });
    it.each(nonExecutableQueryTests)("Non-executable queries - %s", async (_, { query }) => {
        const { errors } = await __1.processGraphqlRequest({
            schema,
            request: {
                query
            }
        });
        expect(errors.length).toBeGreaterThan(0);
        expect(errors).toMatchSnapshot();
    });
    it("Passes a modifiable context object to resolvers", async () => {
        const context = Object.create(null);
        const { data } = await __1.processGraphqlRequest({
            schema,
            request: {
                query: graphql `
          query ModifiesContext {
            modifiesContext
          }
        `
            },
            context
        });
        expect(data.modifiesContext).toBe("Context modified!");
        expect(context).toHaveProperty("modified");
    });
});
//# sourceMappingURL=execution.test.js.map